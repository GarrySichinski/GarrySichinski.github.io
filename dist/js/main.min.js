(function () {
    const doc = document
    const rootEl = doc.documentElement
    const body = doc.body
    /* глобальная переменная ScrollReveal */
    const sr = window.sr = ScrollReveal({ mobile: true })
  
    // Удаляем класс 'no-js' и добавляем класс 'js' на элемент rootEl
    rootEl.classList.remove('no-js')
    rootEl.classList.add('js')
  
    // Добавляем класс 'is-loaded' на body, когда страница загружена
    window.addEventListener('load', function () {
      body.classList.add('is-loaded')
    })
  
    // Функция для анимации при прокрутке
    function revealAnimations () {
      // Анимация для элемента с классом '.device-mockup' внутри '.feature-extended'
      sr.reveal('.feature-extended .device-mockup', {
        duration: 600, // Длительность анимации в миллисекундах
        distance: '100px', // Расстояние, на которое элемент смещается
        easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)', // Плавность анимации
        origin: 'bottom', // Начало анимации с нижней части
        viewFactor: 0.6 // Процент видимости элемента до начала анимации
      })
  
      // Анимация для элемента с классом '.feature-extended-body' внутри '.feature-extended'
      sr.reveal('.feature-extended .feature-extended-body', {
        duration: 600, // Длительность анимации в миллисекундах
        distance: '40px', // Расстояние, на которое элемент смещается
        easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)', // Плавность анимации
        origin: 'top', // Начало анимации с верхней части
        viewFactor: 0.6 // Процент видимости элемента до начала анимации
      })
    }
  
    // Запуск анимаций, если body содержит класс 'has-animations'
    if (body.classList.contains('has-animations')) {
      window.addEventListener('load', revealAnimations)
    }
  
    // Анимация частиц (пузырьков)
    let Bubble = function (parentNode) {
      let self = this
      self.parentNode = parentNode
      self.getCanvasSize()
      // Обновление размеров холста при изменении размера окна
      window.addEventListener('resize', function () {
        self.getCanvasSize()
      })
      self.mouseX = self.canvasWidth / 2
      self.mouseY = self.canvasHeight / 2

      // Обновление положения мыши при движении
      window.addEventListener('mousemove', function (e) {
        self.mouseX = e.clientX
        self.mouseY = e.clientY
      })

      // Обработка данных гироскопа
      if (window.DeviceOrientationEvent) {
        window.addEventListener('deviceorientation', function (event) {
          // Получаем гамма и бета (наклон по горизонтали и вертикали)
          let gamma = event.gamma; // диапазон от -90 до 90
          let beta = event.beta; // диапазон от -180 до 180

          // Увеличиваем чувствительность гироскопа
          let sensitivity = 5; // Увеличьте это значение для большей чувствительности

          // Преобразуем значения гамма и бета в координаты на экране
          self.mouseX = (gamma * sensitivity + 90) / 180 * self.canvasWidth;
          self.mouseY = (beta * sensitivity + 180) / 360 * self.canvasHeight;
        }, true);
      }

      self.randomise() // Инициализация пузырька со случайными параметрами
    }
  
    // Получение размеров холста
    Bubble.prototype.getCanvasSize = function () {
      let self = this
      self.canvasWidth = self.parentNode.clientWidth
      self.canvasHeight = self.parentNode.clientHeight
    }
  
    // Генерация случайного числа в заданном диапазоне
    Bubble.prototype.generateDecimalBetween = function (min, max) {
      return (Math.random() * (min - max) + max).toFixed(2)
    }
  
    // Обновление положения пузырька на экране
    Bubble.prototype.update = function () {
      let self = this
      self.translateX = self.translateX - self.movementX
      self.translateY = self.translateY - self.movementY
      self.posX += ((self.mouseX / (self.staticity / self.magnetism)) - self.posX) / self.smoothFactor
      self.posY += ((self.mouseY / (self.staticity / self.magnetism)) - self.posY) / self.smoothFactor
  
      // Если пузырек выходит за пределы холста, он перемещается обратно вниз и инициализируется заново
      if (self.translateY + self.posY < 0 || self.translateX + self.posX < 0 || self.translateX + self.posX > self.canvasWidth) {
        self.randomise()
        self.translateY = self.canvasHeight
      }
    }
  
    // Инициализация пузырька со случайными параметрами
    Bubble.prototype.randomise = function () {
      let self = this
      self.colors = ['224, 255, 255', '240, 248, 255', '255, 222, 173', '112, 128, 144', '243, 244, 255', '135, 206, 235']
      self.velocity = 3 // Скорость левитации пузырька (чем выше, тем медленнее)
      self.smoothFactor = 35 // Коэффициент сглаживания (чем выше, тем плавнее)
      self.staticity = 50 // Увеличение значения замедляет движение пузырьков при перемещении мыши
      self.magnetism = 0.1 + Math.random() * 4 // Сила притяжения пузырьков к курсору
      self.color = self.colors[Math.floor(Math.random() * self.colors.length)]
      self.alpha = self.generateDecimalBetween(5, 10) / 10 // Прозрачность пузырька
      self.size = self.generateDecimalBetween(0.1, 1.5) // Размер пузырька
      self.posX = 0
      self.posY = 0
      self.movementX = self.generateDecimalBetween(-2, 2) / self.velocity // Горизонтальное смещение
      self.movementY = self.generateDecimalBetween(1, 20) / self.velocity // Вертикальное смещение
      self.translateX = self.generateDecimalBetween(0, self.canvasWidth) // Начальная позиция по X
      self.translateY = self.generateDecimalBetween(0, self.canvasHeight) // Начальная позиция по Y
    }
  
    // Создание фона с пузырьками
    let Background = function (selector) {
      let self = this
      self.canvas = document.getElementById(selector)
      self.ctx = this.canvas.getContext('2d')
      self.dpr = window.devicePixelRatio // Коэффициент плотности пикселей
    }
  
    // Начало анимации пузырьков
    Background.prototype.start = function () {
      let self = this
      self.canvasSize() // Установка размеров холста
      window.addEventListener('resize', function () {
        self.canvasSize()
      })
      self.bubblesList = [] // Список пузырьков
      self.generateBubbles() // Генерация пузырьков
      self.animate() // Запуск анимации
    }
  
    // Установка размеров холста
    Background.prototype.canvasSize = function () {
      let self = this
      self.container = self.canvas.parentNode
      // Определение ширины и высоты окна
      self.w = self.container.offsetWidth
      self.h = self.container.offsetHeight
      self.wdpi = self.w * self.dpr
      self.hdpi = self.h * self.dpr
      // Установка ширины и высоты холста
      self.canvas.width = self.wdpi
      self.canvas.height = self.hdpi
      // Установка атрибутов ширины и высоты
      self.canvas.style.width = self.w + 'px'
      self.canvas.style.height = self.h + 'px'
      // Масштабирование холста
      self.ctx.scale(self.dpr, self.dpr)
    }
  
    // Анимация пузырьков
    Background.prototype.animate = function () {
      let self = this
      self.ctx.clearRect(0, 0, self.canvas.clientWidth, self.canvas.clientHeight)
      self.bubblesList.forEach(function (bubble) {
        bubble.update()
        self.ctx.translate(bubble.translateX, bubble.translateY)
        self.ctx.beginPath()
        self.ctx.arc(bubble.posX, bubble.posY, bubble.size, 0, 2 * Math.PI)
        self.ctx.fillStyle = 'rgba(' + bubble.color + ',' + bubble.alpha + ')'
        self.ctx.fill()
        self.ctx.setTransform(self.dpr, 0, 0, self.dpr, 0, 0)
      })
      /* глобальная функция requestAnimationFrame */
      requestAnimationFrame(this.animate.bind(this))
    }
  
    // Добавление пузырька в список
    Background.prototype.addBubble = function (bubble) {
      return this.bubblesList.push(bubble)
    }
  
    // Генерация пузырьков
    Background.prototype.generateBubbles = function () {
      let self = this
      for (let i = 0; i < self.bubbleDensity(); i++) {
        self.addBubble(new Bubble(self.canvas.parentNode))
      }
    }
  
    // Определение плотности пузырьков
    Background.prototype.bubbleDensity = function () {
      return 500 // Можно настроить по своему усмотрению
    }
  
    // Запуск анимации пузырьков при загрузке страницы
    window.addEventListener('load', function () {
      const heroParticles = new Background('hero-particles')
      const footerParticles = new Background('footer-particles')
      heroParticles.start()
      footerParticles.start()
    })
  
    // Полифилл для requestAnimationFrame
    window.requestAnimFrame = (function () {
      return (
        window.requestAnimationFrame ||
        window.webkitRequestAnimationFrame ||
        window.mozRequestAnimationFrame ||
        window.oRequestAnimationFrame ||
        window.msRequestAnimationFrame ||
        function (callback) {
          window.setTimeout(callback, 1000 / 60)
        }
      )
    })()
  }())
