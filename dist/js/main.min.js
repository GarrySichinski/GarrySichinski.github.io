(function () {
    const doc = document; // Сохранение ссылки на объект `document`
    const rootEl = doc.documentElement; // Сохранение ссылки на корневой элемент HTML
    const body = doc.body; // Сохранение ссылки на элемент body

    // Инициализация ScrollReveal с настройкой отключения для мобильных устройств
    const sr = window.sr = ScrollReveal({ mobile: true });

    // Удаление класса 'no-js' и добавление класса 'js' на корневой элемент, чтобы обозначить, что JS включен
    rootEl.classList.remove('no-js');
    rootEl.classList.add('js');

    // Добавление класса 'is-loaded' на body после полной загрузки страницы
    window.addEventListener('load', function () {
        body.classList.add('is-loaded');
    });

    // Функция для управления анимацией элементов при прокрутке страницы
    function revealAnimations() {
        // Анимация появления элемента с классом '.device-mockup' внутри '.feature-extended'
        sr.reveal('.feature-extended .device-mockup', {
            duration: 600, // Длительность анимации 600 мс
            distance: '100px', // Элемент перемещается на 100px во время анимации
            easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)', // Плавная анимация с использованием кубического Безье
            origin: 'bottom', // Анимация начинается снизу
            viewFactor: 0.6 // Анимация запускается, когда 60% элемента находится в зоне видимости
        });

        // Анимация появления текста внутри '.feature-extended-body'
        sr.reveal('.feature-extended .feature-extended-body', {
            duration: 600, // Длительность анимации 600 мс
            distance: '40px', // Элемент перемещается на 40px во время анимации
            easing: 'cubic-bezier(0.215, 0.61, 0.355, 1)', // Плавная анимация с использованием кубического Безье
            origin: 'top', // Анимация начинается сверху
            viewFactor: 0.6 // Анимация запускается, когда 60% элемента находится в зоне видимости
        });
    }

    // Если body содержит класс 'has-animations', запускаем анимации при загрузке страницы
    if (body.classList.contains('has-animations')) {
        window.addEventListener('load', revealAnimations);
    }

    // Конструктор для создания пузырьков
    let Bubble = function (parentNode) {
        let self = this;
        self.parentNode = parentNode; // Ссылка на родительский элемент, в котором будет находиться пузырек
        self.getCanvasSize(); // Получаем размеры холста

        // Обновление размеров холста при изменении размеров окна
        window.addEventListener('resize', function () {
            self.getCanvasSize();
        });

        // Начальные координаты мыши
        self.mouseX = 0;
        self.mouseY = 0;

        // Обновление координат мыши при ее движении
        window.addEventListener('mousemove', function (e) {
            self.mouseX = e.clientX;
            self.mouseY = e.clientY;
        });

        // Инициализация пузырька со случайными параметрами
        self.randomise();
    };

    // Получение размеров холста
    Bubble.prototype.getCanvasSize = function () {
        let self = this;
        self.canvasWidth = self.parentNode.clientWidth; // Ширина холста равна ширине родительского элемента
        self.canvasHeight = self.parentNode.clientHeight; // Высота холста равна высоте родительского элемента
    };

    // Генерация случайного числа в диапазоне от min до max
    Bubble.prototype.generateDecimalBetween = function (min, max) {
        return (Math.random() * (min - max) + max).toFixed(2);
    };

    // Обновление положения пузырька на экране
    Bubble.prototype.update = function () {
        let self = this;
        self.translateX = self.translateX - self.movementX; // Обновляем координату X пузырька с учетом его движения
        self.translateY = self.translateY - self.movementY; // Обновляем координату Y пузырька с учетом его движения
        self.posX += ((self.mouseX / (self.staticity / self.magnetism)) - self.posX) / self.smoothFactor; // Обновление положения X с учетом мыши
        self.posY += ((self.mouseY / (self.staticity / self.magnetism)) - self.posY) / self.smoothFactor; // Обновление положения Y с учетом мыши

        // Если пузырек выходит за пределы холста, он перемещается обратно вниз и инициализируется заново
        if (self.translateY + self.posY < 0 || self.translateX + self.posX < 0 || self.translateX + self.posX > self.canvasWidth) {
            self.randomise();
            self.translateY = self.canvasHeight;
        }
    };

    // Инициализация пузырька со случайными параметрами
    Bubble.prototype.randomise = function () {
        let self = this;
        self.colors = ['224, 255, 255', '240, 248, 255', '255, 222, 173', '112, 128, 144', '243, 244, 255', '135, 206, 235']; // Массив возможных цветов
        self.velocity = 3; // Скорость левитации пузырька (чем выше, тем медленнее)
        self.smoothFactor = 35; // Коэффициент сглаживания (чем выше, тем плавнее)
        self.staticity = 10; // Статичность пузырьков при перемещении мыши
        self.magnetism = 0.1 + Math.random() * 4; // Сила притяжения пузырьков к курсору
        self.color = self.colors[Math.floor(Math.random() * self.colors.length)]; // Случайный выбор цвета
        self.alpha = self.generateDecimalBetween(5, 10) / 10; // Прозрачность пузырька
        self.size = self.generateDecimalBetween(0.1, 1.5); // Размер пузырька
        self.posX = 0;
        self.posY = 0;
        self.movementX = self.generateDecimalBetween(-2, 2) / self.velocity; // Горизонтальное смещение
        self.movementY = self.generateDecimalBetween(1, 20) / self.velocity; // Вертикальное смещение
        self.translateX = self.generateDecimalBetween(0, self.canvasWidth); // Начальная позиция по X
        self.translateY = self.generateDecimalBetween(0, self.canvasHeight); // Начальная позиция по Y
    };

    // Создание фона с пузырьками
    let Background = function (selector) {
        let self = this;
        self.canvas = document.getElementById(selector); // Получаем ссылку на элемент canvas
        self.ctx = this.canvas.getContext('2d'); // Контекст рисования на холсте
        self.dpr = window.devicePixelRatio; // Коэффициент плотности пикселей
    };

    // Начало анимации пузырьков
    Background.prototype.start = function () {
        let self = this;
        self.canvasSize(); // Установка размеров холста
        window.addEventListener('resize', function () {
            self.canvasSize(); // Обновление размеров холста при изменении размеров окна
        });
        self.bubblesList = []; // Список пузырьков
        self.generateBubbles(); // Генерация пузырьков
        self.animate(); // Запуск анимации
    };

    // Установка размеров холста
    Background.prototype.canvasSize = function () {
        let self = this;
        self.container = self.canvas.parentNode; // Ссылка на родительский элемент
        self.w = self.container.offsetWidth; // Ширина контейнера
        self.h = self.container.offsetHeight; // Высота контейнера
        self.wdpi = self.w * self.dpr; // Ширина с учетом плотности пикселей
        self.hdpi = self.h * self.dpr; // Высота с учетом плотности пикселей
        self.canvas.width = self.wdpi; // Установка ширины холста
        self.canvas.height = self.hdpi; // Установка высоты холста
        self.canvas.style.width = self.w + 'px'; // Установка стилей ширины
        self.canvas.style.height = self.h + 'px'; // Установка стилей высоты
        self.ctx.scale(self.dpr, self.dpr); // Масштабирование контекста
    };

    // Анимация пузырьков
    Background.prototype.animate = function () {
        let self = this;
        self.ctx.clearRect(0, 0, self.canvas.clientWidth, self.canvas.clientHeight); // Очистка холста перед рисованием нового кадра
        self.bubblesList.forEach(function (bubble) { // Обновление каждого пузырька
            bubble.update(); // Обновление положения пузырька
            self.ctx.translate(bubble.translateX, bubble.translateY); // Перемещение контекста в новую позицию пузырька
            self.ctx.beginPath(); // Начало нового пути рисования
            self.ctx.arc(bubble.posX, bubble.posY, bubble.size, 0, 2 * Math.PI); // Рисование круга (пузырька)
            self.ctx.fillStyle = 'rgba(' + bubble.color + ',' + bubble.alpha + ')'; // Установка цвета и прозрачности
            self.ctx.fill(); // Заполнение круга цветом
            self.ctx.setTransform(self.dpr, 0, 0, self.dpr, 0, 0); // Сброс трансформации контекста
        });
        requestAnimationFrame(this.animate.bind(this)); // Рекурсивный вызов анимации на следующий кадр
    };

    // Добавление пузырька в список пузырьков
    Background.prototype.addBubble = function (bubble) {
        return this.bubblesList.push(bubble);
    };

    // Генерация пузырьков
    Background.prototype.generateBubbles = function () {
        let self = this;
        for (let i = 0; i < self.bubbleDensity(); i++) { // Цикл для создания пузырьков
            self.addBubble(new Bubble(self.canvas.parentNode)); // Добавление нового пузырька в список
        }
    };

    // Определение плотности пузырьков
    Background.prototype.bubbleDensity = function () {
        return 650; // Количество пузырьков (можно уменьшить для увеличения производительности)
    };

    // Запуск анимации пузырьков при загрузке страницы
    window.addEventListener('load', function () {
        const heroParticles = new Background('hero-particles'); // Создание объекта анимации для hero-подраздела
        const footerParticles = new Background('footer-particles'); // Создание объекта анимации для footer-подраздела
        heroParticles.start(); // Запуск анимации для hero
        footerParticles.start(); // Запуск анимации для footer
    });

    // Полифилл для requestAnimationFrame для обеспечения совместимости с различными браузерами
    window.requestAnimFrame = (function () {
        return (
            window.requestAnimationFrame ||
            window.webkitRequestAnimationFrame ||
            window.mozRequestAnimationFrame ||
            window.oRequestAnimationFrame ||
            window.msRequestAnimationFrame ||
            function (callback) {
                window.setTimeout(callback, 1000 / 60); // Запасной вариант: вызов callback 60 раз в секунду
            }
        );
    })();

    // Чувствительность гироскопа
    const sensitivity = 5000; // Значение чувствительности к изменению наклона устройства

    // Обработка события deviceorientation для движения пузырьков при наклоне устройства
    window.addEventListener('deviceorientation', function (event) {
        const tiltX = event.gamma; // Значение наклона по оси X
        const tiltY = event.beta; // Значение наклона по оси Y

        // Обновляем координаты мыши на основе гироскопа
        const normalizedX = (tiltX / 90) * window.innerWidth; // Нормализация значения наклона по X
        const normalizedY = (tiltY / 90) * window.innerHeight; // Нормализация значения наклона по Y

        // Обновляем глобальные значения mouseX и mouseY
        Bubble.prototype.mouseX = normalizedX * sensitivity;
        Bubble.prototype.mouseY = normalizedY * sensitivity;
    });

}());
